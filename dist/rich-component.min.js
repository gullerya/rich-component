const t="template",e="htmlUrl",n={};class o extends HTMLElement{constructor(){super();const t=n[this.localName];this.attachShadow({mode:"open"}).appendChild(t.content.cloneNode(!0))}}export{o as ComponentBase,r as initComponent,i as fetchTemplate};async function r(r,a){let l;if(function(t){if(!t||"string"!=typeof t||!/^[a-z0-9]+(-[a-z0-9]+)*-[a-z0-9]+$/.test(t))throw new Error(`invalid element's tag/name: ${t}`);if(n[t])throw new Error(`'${t}' MAY NOT be initialized more than once`)}(r),function(n,r){if(!(r&&r.prototype instanceof o))throw new Error(`invalid class for '${n}'; MUST NOT be null and MUST be an instance of ComponentBase`);if(!(t in r)&&!(e in r)||t in r&&e in r)throw new Error(`'${n}' MUST implement either static getter of '${e}' property returning component's HTML path, or static getter of '${t}' property returning a template`)}(r,a),t in a){if(!(l=a[t])||"TEMPLATE"!==l.nodeName)throw new Error(`'${r}' provided invalid template: ${l}`)}else{const t=a[e];if(!t||"string"!=typeof t)throw new Error(`'${r}' provided invalid HTML URL: ${t}`);const n=await i(t);if(!n)throw new Error(`failed to init template of '${r}' from '${t}'`);(l=document.createElement("template")).innerHTML=n}n[r]=l,customElements.define(r,a)}async function i(t){if(!t||"string"!=typeof t)throw new Error(`invalid HTML template URL: ${t}`);let e=null;const n=await fetch(t);if(n.ok){const o=await n.text();o?e=o:console.error(`failed to fetch HTML template from '${t}', no content`)}else console.error(`failed to fetch HTML template from '${t}', status ${n.status}`);return e}