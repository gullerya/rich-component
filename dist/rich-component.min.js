const e="template",t="htmlUrl",o={};class n extends HTMLElement{constructor(){super();const e=o[this.localName];e?this.attachShadow({mode:"open"}).appendChild(e.content.cloneNode(!0)):console.error(`failed to obtain template for '${this.localName}' by any mean, won't process shadow DOM`)}}export{n as ComponentBase,r as initComponent,i as fetchTemplate};async function r(r,a){if(o[r])throw new Error(`component MAY NOT be initialized more than once, '${r}' is attempted to be initialized more than once`);if(!(a&&a.prototype instanceof n))throw new Error(`invalid component class of '${r}'; MUST NOT be null and MUST be an instance of ComponentBase`);if(!(e in a)&&!(t in a)||e in a&&t in a)throw new Error(`'${r}' MUST implement either static getter of '${t}' property returning component's HTML path, or static getter of '${e}' property returning a template`);let l;if(e in a){if("TEMPLATE"!==(l=a[e]).nodeName)throw new Error(`'${r}' provided invalid template (${l})`)}else{const e=a[t];if(!e||"string"!=typeof e)throw new Error(`'${r}' provided invalid HTML URL (${e})`);const o=await i(e);if(!o)throw new Error(`failed to init template of '${r}' from '${e}'`);(l=document.createElement("template")).innerHTML=o}o[r]=l,customElements.define(r,a)}async function i(e){if(!e||"string"!=typeof e)throw new Error(`invalid HTML template URL '${e}'`);let t=null;const o=await fetch(e);if(o.ok){const n=await o.text();n?t=n:console.error(`failed to fetch HTML template from '${e}', no content`)}else console.error(`failed to fetch HTML template from '${e}', status ${o.status}`);return t}