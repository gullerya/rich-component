const e="template",t="htmlUrl",n={};class o extends HTMLElement{constructor(){super();const e=this.getTemplate();e?this.attachShadow({mode:"open"}).appendChild(e):console.error(`failed to get template for ${this.localName}`)}getTemplate(){let e=null;const t=n[this.localName];if("function"==typeof t){const n=t.call(this,this);n&&"TEMPLATE"===n.nodeName&&(e=n.content.cloneNode(!0))}else e=t.content.cloneNode(!0);return e}}export{o as ComponentBase,r as initComponent,i as fetchTemplate};async function r(r,a){let l;if(function(e){if(!e||"string"!=typeof e||!/^[a-z0-9]+(-[a-z0-9]+)*-[a-z0-9]+$/.test(e))throw new Error(`invalid element's tag/name: ${e}`);if(customElements.get(e))throw new Error(`'${e}' element already defined`)}(r),function(n,r){if(!(r&&r.prototype instanceof o))throw new Error(`invalid class for '${n}'; MUST NOT be null and MUST be an instance of ComponentBase`);if(!(e in r)&&!(t in r)||e in r&&t in r)throw new Error(`'${n}' MUST implement either static getter of '${t}' property returning component's HTML path, or static getter of '${e}' property returning a template`)}(r,a),e in a){if((!(l=a[e])||"TEMPLATE"!==l.nodeName)&&"function"!=typeof l)throw new Error(`'${r}' provided invalid template: ${l}`)}else{const e=a[t];if(!e||"string"!=typeof e)throw new Error(`'${r}' provided invalid HTML URL: ${e}`);const n=await i(e);if(!n)throw new Error(`failed to init template of '${r}' from '${e}'`);(l=document.createElement("template")).innerHTML=n}n[r]=l,customElements.define(r,a)}async function i(e){if(!e||"string"!=typeof e)throw new Error(`invalid HTML template URL: ${e}`);let t=null;const n=await fetch(e);if(n.ok){const o=await n.text();o?t=o:console.error(`failed to fetch HTML template from '${e}', no content`)}else console.error(`failed to fetch HTML template from '${e}', status ${n.status}`);return t}