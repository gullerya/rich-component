const e="template",t="htmlUrl",n={};class o extends HTMLElement{constructor(){super();const e=n[this.localName];e?this.attachShadow({mode:"open"}).appendChild(e.content.cloneNode(!0)):console.error(`no template registered for '${this.localName}', won't inject shadow DOM`)}}export{o as ComponentBase,r as initComponent,i as fetchTemplate};async function r(r,a){let l;if(function(e){if(!e||"string"!=typeof e||!/^[a-z]+(-[a-z]+)*-[a-z]+$/.test(e))throw new Error(`invalid element's tag/name: ${e}`);if(n[e])throw new Error(`'${e}' MAY NOT be initialized more than once`)}(r),function(n,r){if(!(r&&r.prototype instanceof o))throw new Error(`invalid class for '${n}'; MUST NOT be null and MUST be an instance of ComponentBase`);if(!(e in r)&&!(t in r)||e in r&&t in r)throw new Error(`'${n}' MUST implement either static getter of '${t}' property returning component's HTML path, or static getter of '${e}' property returning a template`)}(r,a),e in a){if(!(l=a[e])||"TEMPLATE"!==l.nodeName)throw new Error(`'${r}' provided invalid template: ${l}`)}else{const e=a[t];if(!e||"string"!=typeof e)throw new Error(`'${r}' provided invalid HTML URL: ${e}`);const n=await i(e);if(!n)throw new Error(`failed to init template of '${r}' from '${e}'`);(l=document.createElement("template")).innerHTML=n}n[r]=l,customElements.define(r,a)}async function i(e){if(!e||"string"!=typeof e)throw new Error(`invalid HTML template URL '${e}'`);let t=null;const n=await fetch(e);if(n.ok){const o=await n.text();o?t=o:console.error(`failed to fetch HTML template from '${e}', no content`)}else console.error(`failed to fetch HTML template from '${e}', status ${n.status}`);return t}